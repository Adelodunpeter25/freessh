2. Hardcoded Initial Size ⚠️
  go
   // create.go line 107
   term.Initialize(24, 80)
   
   - Should use actual terminal dimensions from frontend
   - Can cause display issues on first render
   
   
   
4. Missing Context for Cancellation ⚠️
   - No context.Context usage for graceful shutdown
   - Goroutines in output.go rely on channel closure

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. Race Condition in Close() ⚠️
  
go
   func (t *Terminal) Close() error {
       t.mu.Lock()
       defer t.mu.Unlock()
       
       if t.closed { return nil }
       t.closed = true
       
       if t.pty != nil { t.pty.Close() }
       if t.cmd != nil && t.cmd.Process != nil {
           t.cmd.Process.Kill() // Should use SIGTERM first
       }
       return nil
   }
   

   - Kills process immediately without graceful shutdown
   - Should send SIGTERM, wait, then SIGKILL
   
  
  2. No Reconnection on Terminal Failure ❌
  
go
   // output.go - if reader.Read() fails, goroutine exits
   n, err := reader.Read(buf)
   if err != nil {
       if err != io.EOF {
           as.ErrorChan <- err
       }
       return // Session is dead, no recovery
   }
   

   - SSH client has reconnection, but terminal doesn't
   - Should trigger session reconnection
   
   
   3. Hardcoded Buffer Size ⚠️
  go
   // output.go
   buf := make([]byte, 4096)
   
   - 4KB might be suboptimal for high-bandwidth scenarios
   - Consider 8KB or 16KB for better throughput
   
   
   
   2. Ref Stale Closure ⚠️
  
tsx
   onDataRef.current = onData
   onResizeRef.current = onResize
   
   // But xterm.onData uses closure:
   xterm.onData((data) => onDataRef.current(data))
   

   - Works, but pattern is inconsistent
   - Could use useCallback with proper deps
   
   
   4. Dispose Called Twice ⚠️
  
tsx
   useEffect(() => {
       if (xtermRef.current) {
           xtermRef.current.dispose() // Dispose old
       }
       const xterm = new XTerm(...)
       
       return () => {
           xterm.dispose() // Dispose again
           xtermRef.current = null
       }
   }, [onReady])
   

   - First dispose is redundant since ref is set after
   
   
   1. Cols/Rows Confusion ⚠️
  
tsx
   // TerminalPane calls: onResize(cols, rows)
   // useTerminal.resize receives: (cols, rows)
   // But sends to backend: resize(sessionId, rows, cols)
   
   const resize = useCallback((cols: number, rows: number) => {
       terminalService.resize(sessionId, rows, cols) // Swapped!
   }, [sessionId])
   

   - **This is a bug!** Parameter order is inconsistent
   - xterm uses (cols, rows), backend expects (rows, cols)
   - Works by accident because both are swapped
   
   
   
   1. Terminal Scrollback Persistence - Lost on reconnect
2. Session Recording - No way to save terminal output
3. Bracketed Paste Mode - Large pastes can trigger commands
4. Terminal Bell - No audio/visual bell support
5. Title Change Sequences - OSC sequences not handled
6. Sixel/Image Support - Modern terminals support images


High Priority:
1. Fix cols/rows parameter order bug
2. Add Process.Wait() to local terminal cleanup
3. Add context-based cancellation to goroutines
4. Implement stderr visual distinction (red text)
5. Add resize debouncing (300ms)

Medium Priority:
6. Increase buffer sizes (8KB read, 500 message channel)
7. Implement output batching (collect 100ms worth)
8. Add backpressure mechanism
9. Validate resize dimensions
10. Add error boundaries to terminal components

Low Priority:
11. Implement terminal split
12. Add session recording
13. Support bracketed paste mode
14. Add terminal bell
15. Persist search state